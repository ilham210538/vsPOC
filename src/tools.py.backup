import os
from datetime import datetime, timedelta, timezone
from dotenv import load_dotenv
from azure.identity import ClientSecretCredential
from msgraph import GraphServiceClient

load_dotenv(os.path.join(os.path.dirname(os.path.dirname(__file__)), '.env'))

# ---------- Graph client (client-credentials) ----------
def graph_client() -> GraphServiceClient:
    cred = ClientSecretCredential(
        tenant_id=os.environ["GRAPH_TENANT_ID"],
        client_id=os.environ["GRAPH_CLIENT_ID"],
        client_secret=os.environ["GRAPH_CLIENT_SECRET"],
    )
    return GraphServiceClient(credentials=cred, scopes=["https://graph.microsoft.com/.default"])

print("Tenant:", os.environ.get("GRAPH_TENANT_ID"))
print("Client:", os.environ.get("GRAPH_CLIENT_ID"))
print("Secret:", "***" if os.environ.get("GRAPH_CLIENT_SECRET") else None)

def _tz() -> str:
    return os.getenv("DEFAULT_TZ", "UTC")

def _default_user() -> str:
    return os.getenv("DEFAULT_USER_UPN")

# ---------- Tool 1: Read schedule (calendarView) ----------
def read_schedule(
    user_upn: str | None = None,
    start_iso: str | None = None,
    end_iso: str | None = None,
    timezone_name: str | None = None,
    select: list[str] | None = None,
    top: int | None = None,
) -> dict:
    """
    Returns events in [start_iso, end_iso] for user's default calendar.
    If start/end missing, returns next 7 days from now.
    """
    user = user_upn or _default_user()
    if not user:
        raise ValueError("user_upn is required")

    now_utc = datetime.now(timezone.utc)
    if not start_iso or not end_iso:
        start_iso = now_utc.isoformat()
        end_iso = (now_utc + timedelta(days=7)).isoformat()

    tz = timezone_name or _tz()
    client = graph_client()

    base = f"https://graph.microsoft.com/v1.0/users/{user}/calendarView"
    url = f"{base}?startDateTime={start_iso}&endDateTime={end_iso}"
    if select:
        url += f"&$select={','.join(select)}"
    if top:
        url += f"&$top={int(top)}"

    req = client.users.by_user_id(user).calendar_view.with_url(url)
    request_info = req.to_get_request_information()
    request_info.headers.add("Prefer", f'outlook.timezone="{tz}"')  # keep the quotes

    import asyncio
    from kiota_abstractions.api_error import APIError

    async def _go():
        try:
            # 3 positional args: (request_info, response_type, error_map)
            return await client.request_adapter.send_async(request_info, dict, None)
        except APIError as ae:
            # Kiota APIError: expose status and message (often includes Graph error JSON)
            status = getattr(ae, "response_status_code", None)
            detail = getattr(ae, "message", "")
            # Some tenants include inner error JSON in the message; print fully for debugging:
            raise RuntimeError(f"Graph error {status}: {detail}") from ae
        except Exception as e:
            raise

    return asyncio.run(_go())

# ---------- Tool 2: Create a meeting (book slot) ----------
def create_meeting(
    user_upn: str | None,
    subject: str,
    start_iso: str,
    end_iso: str,
    timezone_name: str | None = None,
    attendees: list[str] | None = None,
    body_html: str | None = None,
    location: str | None = None,
    allow_new_time_proposals: bool = True,
    is_online_meeting: bool = True,
) -> dict:
    """
    Creates an event on user's default calendar for the given window.
    """
    user = user_upn or _default_user()
    if not user:
        raise ValueError("user_upn is required")

    tz = timezone_name or _tz()
    client = graph_client()

    event = {
        "subject": subject,
        "start": {"dateTime": start_iso, "timeZone": tz},
        "end": {"dateTime": end_iso, "timeZone": tz},
        "allowNewTimeProposals": allow_new_time_proposals,
    }
    if body_html:
        event["body"] = {"contentType": "HTML", "content": body_html}
    if location:
        event["location"] = {"displayName": location}
    if attendees:
        event["attendees"] = [{"emailAddress": {"address": a}, "type": "required"} for a in attendees]
    if is_online_meeting:
        event["isOnlineMeeting"] = True
        event["onlineMeetingProvider"] = "teamsForBusiness"

    import asyncio
    async def _create():
        try:
            # High-level builder call (typed Event model)
            created = await client.users.by_user_id(user).events.post(body=event)
            web_link = getattr(created, "web_link", None) or getattr(created, "webLink", None)
            event_id = getattr(created, "id", None) or (created.get("id") if isinstance(created, dict) else None)
            return {"status": "created", "eventId": event_id, "webLink": web_link}
        except Exception as e:
            msg = str(e)
            if "403" in msg:
                raise PermissionError(
                    "Graph 403 Forbidden when creating event. Ensure Calendars.ReadWrite (Application) "
                    "has admin consent and your mailbox is within the Exchange Application Access Policy."
                ) from e
            raise
    return asyncio.run(_create())
